/*******************************************************************************
 * GBuffer.ubo
 *------------------------------------------------------------------------------
 * Not technically a ubo - but there is no clean way to bind the GBuffer.
 ******************************************************************************/

#ifndef   GBUFFER_UBO
#define   GBUFFER_UBO

#include <Math.glsl>
#include <EncodeDecode.glsl>

uniform highp sampler2D geometryTexture;
uniform highp sampler2D materialTexture;
uniform highp sampler2D surfaceTexture;
uniform highp sampler2D backbufferTexture;
uniform highp sampler2D lightbufferTexture;
uniform highp sampler2D depthTexture;

highp float depthCoord(highp vec2 uv)
{
  return texture(depthTexture, uv).r;
}

highp float depth()
{
  return depthCoord(uvCoord());
}

highp float linearDepthCoord(highp vec2 uv)
{
  return linearizeDepth(depthCoord(uv));
}

highp float linearDepth()
{
  return linearDepthCoord(uvCoord());
}

highp vec3 clipPositionCoord(vec2 uv)
{
  return vec3(uv * 2.0 - 1.0, depthCoord(uv) * 2.0 - 1.0);
}

highp vec3 clipPosition()
{
  return clipPositionCoord(uvCoord());
}

highp vec3 viewPositionCoord(vec2 uv)
{
  highp vec4 clipPos = vec4(clipPositionCoord(uv), 1.0);
  highp vec4 viewPos = clipToView * clipPos;
  return (viewPos.xyz / viewPos.w);
}

highp vec3 viewPosition()
{
  return viewPositionCoord(uvCoord());
}

highp vec3 worldPositionCoord(vec2 uv)
{
  highp vec4 clipPos = vec4(clipPositionCoord(uv), 1.0);
  highp vec4 worldPos = clipToWorld * clipPos;
  return (worldPos.xyz / worldPos.w);
}

highp vec3 worldPosition()
{
  return worldPositionCoord(uvCoord());
}

highp vec3 normalCoord(highp vec2 uv)
{
  return decodeNormal(texture(geometryTexture, uv).xy);
}

highp vec3 normal()
{
  return normalCoord(uvCoord());
}

highp vec3 diffuseCoord(highp vec2 uv)
{
  return texture(materialTexture, uv).xyz;
}

highp vec3 diffuse()
{
  return diffuseCoord(uvCoord());
}

highp vec4 specularCoord(highp vec2 uv)
{
  highp float specColor = texture(materialTexture, uv).z;
  highp float specExponent = texture(surfaceTexture, uv).w;
  return vec4(specColor, specColor, specColor, specExponent);
}

highp vec4 specular()
{
  return specularCoord(uvCoord());
}

highp vec2 velocityCoord(highp vec2 uv)
{
  return texture(geometryTexture, uv).zw;
}

highp vec2 velocity()
{
  return velocityCoord(uvCoord());
}

highp vec4 backbufferCoord(highp vec2 uv)
{
  return texture(backbufferTexture, uv);
}

highp vec4 backbuffer()
{
  return backbufferCoord(uvCoord());
}

highp vec4 lightbufferCoord(highp vec2 uv)
{
  return texture(lightbufferTexture, uv);
}

highp vec4 lightbuffer()
{
  return lightbufferCoord(uvCoord());
}

#endif // GBUFFER_UBO
