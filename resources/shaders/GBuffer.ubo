#ifndef   GBUFFER_UBO
#define   GBUFFER_UBO

#include <Math.glsl>
#include <EncodeDecode.glsl>

uniform sampler2D geometryTexture;
uniform sampler2D materialTexture;
uniform sampler2D surfaceTexture;
uniform sampler2D backbufferTexture;
uniform sampler2D lightbufferTexture;
uniform sampler2D depthTexture;

float depthCoord(vec2 uv)
{
  return texture2D(depthTexture, uv).r;
}

float depth()
{
  return depthCoord(uvCoord());
}

vec3 positionCoord(vec2 uv)
{
  float z = depthCoord(uv);
  vec4 sPos = vec4(uv * 2.0 - 1.0, z * 2.0 - 1.0, 1.0);
  vec4 wPos = clipToWorld * sPos;
  return (wPos.xyz / wPos.w);
}

vec3 position()
{
  return positionCoord(uvCoord());
}

vec3 normalCoord(vec2 uv)
{
  return decodeNormal(texture2D(geometryTexture, uv).xy);
}

vec3 normal()
{
  return normalCoord(uvCoord());
}

vec3 diffuseCoord(vec2 uv)
{
  return texture2D(materialTexture, uv).xyz;
}

vec3 diffuse()
{
  return diffuseCoord(uvCoord());
}

vec4 specularCoord(vec2 uv)
{
  float specColor = texture2D(materialTexture, uv).z;
  float specExponent = texture2D(surfaceTexture, uv).w;
  return vec4(specColor, specColor, specColor, specExponent);
}

vec4 specular()
{
  return specularCoord(uvCoord());
}

vec2 velocityCoord(vec2 uv)
{
  return texture2D(geometryTexture, uv).zw;
}

vec2 velocity()
{
  return velocityCoord(uvCoord());
}

vec4 backbufferCoord(vec2 uv)
{
  return texture2D(backbufferTexture, uv);
}

vec4 backbuffer()
{
  return backbufferCoord(uvCoord());
}

vec4 lightbufferCoord(vec2 uv)
{
  return texture2D(lightbufferTexture, uv);
}

vec4 lightbuffer()
{
  return lightbufferCoord(uvCoord());
}

#endif // GBUFFER_UBO
