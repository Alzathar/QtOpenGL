/*******************************************************************************
 * GBuffer.ubo
 *------------------------------------------------------------------------------
 * Not technically a ubo - but there is no clean way to bind the GBuffer.
 ******************************************************************************/

#ifndef   GBUFFER_UBO
#define   GBUFFER_UBO

#include <Math.glsl>
#include <EncodeDecode.glsl>

uniform highp sampler2D geometryTexture;
uniform highp sampler2D materialTexture;
uniform highp sampler2D surfaceTexture;
uniform highp sampler2D backbufferTexture;
uniform highp sampler2D lightbufferTexture;
uniform highp sampler2D depthTexture;

highp float depth(highp vec2 uv)
{
  return texture(depthTexture, uv).r;
}

highp float depth()
{
  return depth(uvCoord());
}

highp float linearDepth(highp vec2 uv)
{
  return linearizeDepth(depth(uv));
}

highp float linearDepth()
{
  return linearDepth(uvCoord());
}

highp vec3 clipPosition(vec2 uv)
{
  return vec3(uv * 2.0 - 1.0, depth(uv) * 2.0 - 1.0);
}

highp vec3 clipPosition()
{
  return clipPosition(uvCoord());
}

highp vec3 viewPosition(vec2 uv)
{
  highp vec4 clipPos = vec4(clipPosition(uv), 1.0);
  highp vec4 viewPos = clipToView * clipPos;
  return (viewPos.xyz / viewPos.w);
}

highp vec3 viewPosition()
{
  return viewPosition(uvCoord());
}

highp vec3 worldPosition(vec2 uv)
{
  highp vec4 clipPos = vec4(clipPosition(uv), 1.0);
  highp vec4 worldPos = clipToWorld * clipPos;
  return (worldPos.xyz / worldPos.w);
}

highp vec3 worldPosition()
{
  return worldPosition(uvCoord());
}

highp vec3 normal(highp vec2 uv)
{
  return decodeNormal(texture(geometryTexture, uv).xy);
}

highp vec3 normal()
{
  return normal(uvCoord());
}

highp vec3 diffuse(highp vec2 uv)
{
  return texture(materialTexture, uv).xyz;
}

highp vec3 diffuse()
{
  return diffuse(uvCoord());
}

highp vec4 specular(highp vec2 uv)
{
  highp vec3 specColor = decodeSpecularColor(texture(materialTexture, uv).w);
  highp float specExponent = decodeSpecularExponent(texture(surfaceTexture, uv).x);
  return vec4(specColor, specExponent);
}

highp vec4 specular()
{
  return specular(uvCoord());
}

highp vec2 velocity(highp vec2 uv)
{
  return texture(geometryTexture, uv).zw;
}

highp vec2 velocity()
{
  return velocity(uvCoord());
}

highp vec4 backbuffer(highp vec2 uv)
{
  return texture(backbufferTexture, uv);
}

highp vec4 backbuffer()
{
  return backbuffer(uvCoord());
}

highp vec4 lightbuffer(highp vec2 uv)
{
  return texture(lightbufferTexture, uv);
}

highp vec4 lightbuffer()
{
  return lightbuffer(uvCoord());
}

struct gdata
{
  vec3 normal;
  vec3 diffuse;
  vec4 specular;
};

highp gdata gbufferData(highp vec2 uv)
{
  highp vec2 geometryData = texture(geometryTexture, uv).xy;
  highp vec4 materialData = texture(materialTexture, uv);
  highp float surfaceData = texture(surfaceTexture, uv).x;
  return gdata(decodeNormal(geometryData.xy), materialData.xyz, vec4(decodeSpecularColor(materialData.w), decodeSpecularExponent(surfaceData)));
}

highp gdata gbufferData()
{
  return gbufferData(uvCoord());
}

#endif // GBUFFER_UBO
